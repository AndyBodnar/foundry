---
# Foundry MLOps Platform - Secrets Template
# IMPORTANT: This is a template file. Do NOT commit actual secrets to version control.
# Use sealed-secrets, external-secrets, or Vault for production secret management.
#
# To create the actual secret:
# 1. Copy this file and fill in the base64-encoded values
# 2. Use `kubectl create secret generic foundry-secrets --from-literal=KEY=VALUE`
# 3. Or use an external secrets manager like HashiCorp Vault
#
# Example: echo -n 'your-password' | base64
#
apiVersion: v1
kind: Secret
metadata:
  name: foundry-secrets
  namespace: foundry
  labels:
    app.kubernetes.io/name: foundry
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: foundry-mlops
  annotations:
    # For sealed-secrets integration
    # sealedsecrets.bitnami.com/managed: "true"
    description: "Foundry platform secrets - DO NOT COMMIT ACTUAL VALUES"
type: Opaque
data:
  # PostgreSQL Credentials
  # echo -n 'foundry' | base64
  POSTGRES_USER: Zm91bmRyeQ==
  # echo -n 'CHANGE_ME_IN_PRODUCTION' | base64
  POSTGRES_PASSWORD: Q0hBTkdFX01FX0lOX1BST0RVQ1RJT04=

  # TimescaleDB Credentials
  # echo -n 'foundry_ts' | base64
  TIMESCALE_USER: Zm91bmRyeV90cw==
  # echo -n 'CHANGE_ME_IN_PRODUCTION' | base64
  TIMESCALE_PASSWORD: Q0hBTkdFX01FX0lOX1BST0RVQ1RJT04=

  # Redis Password
  # echo -n 'CHANGE_ME_IN_PRODUCTION' | base64
  REDIS_PASSWORD: Q0hBTkdFX01FX0lOX1BST0RVQ1RJT04=

  # S3/MinIO Credentials
  # echo -n 'foundry_minio' | base64
  S3_ACCESS_KEY: Zm91bmRyeV9taW5pbw==
  # echo -n 'CHANGE_ME_IN_PRODUCTION' | base64
  S3_SECRET_KEY: Q0hBTkdFX01FX0lOX1BST0RVQ1RJT04=

  # JWT Secret Key (use a cryptographically secure random string)
  # python -c "import secrets; print(secrets.token_urlsafe(64))" | base64
  JWT_SECRET_KEY: Q0hBTkdFX01FX1VTSU5HX1NFQ1VSRV9SQU5ET01fU1RSSU5H

  # API Encryption Key (for encrypting sensitive data at rest)
  # python -c "import secrets; print(secrets.token_urlsafe(32))" | base64
  ENCRYPTION_KEY: Q0hBTkdFX01FX1VTSU5HX1NFQ1VSRV9SQU5ET01fU1RSSU5H

  # OAuth/OIDC Configuration (if using SSO)
  # OIDC_CLIENT_ID: ""
  # OIDC_CLIENT_SECRET: ""

  # External Service API Keys
  # SLACK_WEBHOOK_URL: ""
  # PAGERDUTY_INTEGRATION_KEY: ""
  # SENDGRID_API_KEY: ""

---
# Docker Registry Secret (for pulling images from private registry)
apiVersion: v1
kind: Secret
metadata:
  name: foundry-registry-secret
  namespace: foundry
  labels:
    app.kubernetes.io/name: foundry
    app.kubernetes.io/component: registry
type: kubernetes.io/dockerconfigjson
data:
  # Generate with:
  # kubectl create secret docker-registry foundry-registry-secret \
  #   --docker-server=YOUR_REGISTRY \
  #   --docker-username=YOUR_USERNAME \
  #   --docker-password=YOUR_PASSWORD \
  #   --docker-email=YOUR_EMAIL \
  #   --dry-run=client -o yaml
  .dockerconfigjson: e30=
---
# TLS Certificate Secret (template)
# For production, use cert-manager with Let's Encrypt or your CA
#
# NOTE: This secret should be created by cert-manager or manually.
# Do NOT apply this template directly - it will fail validation.
# Use one of the following methods:
#
# Method 1: cert-manager (recommended for production)
# The Ingress annotations will trigger cert-manager to create this secret automatically
#
# Method 2: Manual creation with kubectl
# kubectl create secret tls foundry-tls \
#   --cert=path/to/tls.crt \
#   --key=path/to/tls.key \
#   -n foundry
#
# Method 3: Self-signed for development (not for production)
# openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
#   -keyout tls.key -out tls.crt \
#   -subj "/CN=foundry.example.com"
# kubectl create secret tls foundry-tls --cert=tls.crt --key=tls.key -n foundry
